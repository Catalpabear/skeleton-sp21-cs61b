# binary search
$\large O(logN)$
# selection sort
思路:遍历找到最小的，与第一个交换位置
```java
for(int i=0;i<len;i++){
    for(int j=i;j<len;j++){
        int index=findminindex();//这个函数内无循环，为方便，省略
        swap(i,index);
    }
}
```
$\large O (N^2)$
# merge sort
归并排序有两个要点:
- 对两个已经排序好的数组进行整合,新数组已排序好; $\large O (N)$ 
- 无限划分原数组至 **只有一个元素**(可视为已排序好) ;  $\large O(logN)$
    
$\large O(NlogN)$

# index-elem array
这是不相交集合的构建思路  

- 将数组索引视为非负整数集合的元素是一种可能带来便利的好法子  
  
- 将每个集合视为树结构  
  
- 然后可以使用数组内容储存集合元素的索引作为指针,若为-1说明是父

- 树结构每次遍历回根节点会有最差O(N)的复杂度,为防止这一点

- 在连接操作时有意识将较小树连接到较大树,复杂度降到O(logN)

- 可以凭高度或节点数判断树的大小

- 因为本质储存的是集合,我们可以在连接操作的遍历过程中  
  将遍历的每一边都连接到根节点,对集合的储存没有影响,复杂度变为常数时间  
