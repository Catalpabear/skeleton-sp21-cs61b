
[Goto Overview](./总览.md)

---

讲点理论
### 树
一般的树， 由一组节点和一组连接节点的边组成， 任意两节点之间都只有一条路径
根树 (rooted tree) 有指定根节点的树，除了根节点之外，每个节点都恰好有一个父节点

#### 树的遍历

介绍了四种遍历LevelOrder, preorder inorder , postorder ; 每种遍历都有其应用 . 以文件目录树为例:

- 打印文件树内容时, 使用前序遍历
- 计算文件大小时, 使用后序遍历

levelorder 层序遍历, 实现比后面三个更复杂, 之后再来补充

### 图

图， 由一组节点和一组连接节点的边组成, 树其实是特殊的图, 图一般不允许自环

图可以细分, cyclic acyclic undirected directed 四个性质组成四种图
- 有环无向图
- 有向无环图
- 环向图
- 无向无环图  

还有带标签的图 graph with edge label  

#### 关于图的问题

图看起来就复杂, 我们如果实现图数据结构时, 有哪些方法是可以写在接口里的?
- connected(Node , Node)  -> 判断两个顶点是否存在路径
- isConnected()                    -> 所有顶点之间是否存在路径 -> 图是否连通
- shortPath(Node, Node)     -> 两个顶点之间的最短路径是什么
- isBiconnected()                  ->  是否存在一个顶点，其移除会使图变得不连通
- isCyclic()                             -> 图是否包含任何循环
- EulerTour()                          -> 图中是否存在欧拉回路
- GamiltonTour()                   -> 图中是否存在哈密顿回路
- Isomorphism(Graph)          -> 两个图是否同构

#### connected(Node, Node)

我们开始解决第一个问题, 使用递归会更好理解:
```java
public boolean connected(Node s, Node t){
	if(s == t){
		return true;
	}
	mark(s);
	for(Node child: unmarkedneighbor){
		if(connected(child,t)){
			return true;
		}
	}
	return false;
}
```
这个算法叫做图的 **深度优先遍历** (depth-first traversal)  
下面我们介绍 **广度优先遍历** (breadth first traversal), 也叫层序遍历

#### BFS
BFS是广度优先搜索的缩写, 会按离主节点的距离划分层级,进行遍历, 我们可以使用这种算法实现
**shortPath()** 方法, 
DFS采用递归, 即栈实现功能, 而BFS使用了队列,下面使用伪代码讲解思路:
```java
create a queue
for(Node s: numarkedNode){
	mark(s);
	queue.add(s);
	edgeTo[n] = s;
	distTo[n] = distTo[s] + 1;
}
shortlength = distTo[t];
```
(没写好,我改日再战)


### 实现图

我们需要一些底层数据结构来实现图, 如何选择是很大的学问,书上提供了一些:

- 邻接矩阵
- 边集合
- 邻接表

实现图也需要必要的方法和成员:
```java
public class Graph {
  public Graph(int V):               // Create empty graph with v vertices
  public void addEdge(int v, int w): // add an edge v-w 在VW之间添加边
  Iterable<Integer> adj(int v):      // vertices adjacent to v  与V点相邻的点
  int V():                           // number of vertices 顶点
  int E():                           // number of edges  边
```
