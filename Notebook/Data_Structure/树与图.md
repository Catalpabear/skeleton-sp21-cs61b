
[Goto Overview](./总览.md)

---

讲点理论
### 树
一般的树， 由一组节点和一组连接节点的边组成， 任意两节点之间都只有一条路径
根树 (rooted tree) 有指定根节点的树，除了根节点之外，每个节点都恰好有一个父节点

#### 树的遍历

介绍了四种遍历LevelOrder, preorder inorder , postorder ; 每种遍历都有其应用 . 以文件目录树为例:

- 打印文件树内容时, 使用前序遍历
- 计算文件大小时, 使用后序遍历

levelorder 层序遍历, 实现比后面三个更复杂, 之后再来补充

### 图

图， 由一组节点和一组连接节点的边组成, 树其实是特殊的图, 图一般不允许自环

图可以细分, cyclic acyclic undirected directed 四个性质组成四种图
- 有环无向图
- 有向无环图
- 环向图
- 无向无环图  

还有带标签的图 graph with edge label  

#### 关于图的问题

图看起来就复杂, 我们如果实现图数据结构时, 有哪些方法是可以写在接口里的?
- connected(Node , Node)  -> 判断两个顶点是否存在路径
- isConnected()                    -> 所有顶点之间是否存在路径 -> 图是否连通
- shortPath(Node, Node)     -> 两个顶点之间的最短路径是什么
- isBiconnected()                  ->  是否存在一个顶点，其移除会使图变得不连通
- isCyclic()                             -> 图是否包含任何循环
- EulerTour()                          -> 图中是否存在欧拉回路
- GamiltonTour()                   -> 图中是否存在哈密顿回路
- Isomorphism(Graph)          -> 两个图是否同构

#### connected(Node, Node)

我们开始解决第一个问题, 使用递归会更好理解:
```java
public boolean connected(Node s, Node t){
	if(s == t){
		return true;
	}
	mark(s);
	for(Node child: unmarkedneighbor){
		if(connected(child,t)){
			return true;
		}
	}
	return false;
}
```
这个算法叫做图的 **深度优先遍历** (depth-first traversal)  
下面我们介绍 **广度优先遍历** (breadth first traversal), 也叫层序遍历

#### BFS
BFS是广度优先搜索的缩写, 会按离主节点的距离划分层级,进行遍历, 我们可以使用这种算法实现
**shortPath()** 方法, 
DFS采用递归, 即栈实现功能, 而BFS使用了队列,下面使用伪代码讲解思路:
```java
create a queue
queue.add(s);
while(unmarkedNode.noEmpty()){
	Node access = queue.remove();
	mark(access);
	for(Node n: access.unmarkedNeighbor()){
		queue.add(n);
	}
	sout(access);//打印出遍历到的节点
}
```
上面这个思路可用于遍历, 求最短路径时, 可以遍历到某个节点时计算其到`s`节点的距离  
这个算法实际上是以`s` 为根节点, 把整个图给拉成树, 这样最短路径一目了然

##### BFS VS DFS
BFS对于茂密的图不太好使, 会涉及频繁的出队入队 ; DFS 对于细长的图, 可能涉及上千的递归调用  
两者各有缺点.

### 实现图

我们需要一些底层数据结构来实现图, 如何选择是很大的学问,书上提供了一些:

- 邻接矩阵
- 边集合
- 邻接表

实现图也需要必要的方法和成员:
```java
public class Graph {
  public Graph(int V):               // Create empty graph with v vertices
  public void addEdge(int v, int w): // add an edge v-w 在VW之间添加边
  Iterable<Integer> adj(int v):      // vertices adjacent to v  与V点相邻的点
  int V():                           // number of vertices 顶点
  int E():                           // number of edges  边
  public boolean hasEdge(int v, int w);// 两顶点之间是否存在边
```

书上没有细讲, 我们进行知识补充 :
- [邻接矩阵]
- [邻接表]


#### 边集
边集比较简单, 我们先讲讲它的实现:  
我们定义一个Edge类:
```java
private class Edge{
	private int label; //标签图中,可能需要使用的标签
	private Node src;
	private Node dest; // 无向图可以不考虑这个
	private int weight; //边的权重
}
public class EdgeGraph{
	private Set<Edge> edges = new HashSet<>();
	________
}
```
目前虽然叫边集, 但是更好的方案是使用List储存Edge类, "只有在需要频繁边查找和删除，且不需要平行边的场景下，才考虑使用 Set"  

边集通常不是实现图的主要手段 :worried:

#### 邻接矩阵
我们可能在离散数学课里面学到过, 构建一个二维正方形布尔数组, 索引表示顶点, 数组内容表示点与点之间是否有边;     
对于无向图, 可以只填充半数的内容, 因为是对称的.

|     | 0   | 1   | 2   | 3   | 4   |
| --- | --- | --- | --- | --- | --- |
| 0   | 0   | 1   | 0   | 1   | 1   |
| 1   | 0   | 0   | 1   | 1   | 1   |
| 2   | 0   | 0   | 0   | 1   | 0   |
| 3   | 0   | 0   | 0   | 0   | 1   |
| 4   | 0   | 0   | 0   | 0   | 0   |
  
这是用邻接矩阵表示的下面的图
#### 邻接表
构建一个二维不等长数组, 数组索引指向的数组内容存放这个顶点指向的其他顶点, 例如:
![](./picturefield/Adjacency_List.png)
0索引储存一个数组 \[4, 3, 1] 表示0顶点有指向 4 3 1 的边

### Dijkstra 算法

当边出现权值时, BFS算法往往会找到意想不到的路径[^1] (可能还是最长路径!)
这节我们基于贪心算法, 改进DFS算法, 用Dijkstra 算法解决最短路径问题     
- 思考1: 我们可以使用DFS, 在访问到图的顶点时更新其到原点的距离, 但是可能有时最优解法需要重新访问已标记的点, 我们需要在更新某一节点的距离时, 取消其邻居的所有标记, 才能找到最优解->太麻烦了!  
- 思考2: 我们不妨先减少DFS对每个路径的访问, 优先访问当前节点最短路径, 这样我们又需要进行一次邻居遍历, 找出里面的最小值(虽然这不算什么), 但是这种做法属于剪枝, 未能充分访问图内的所有节点, 不一定最优(有可能又找到最长路径!)  
- 最终答案: 我们可以改进BFS的队列策略, 使用最小优先队列[^2], 这样保证出队的第一个是最小边顶点, 又能保证充分访问所有顶点!

只要所有边都是非负的[^3]，Dijkstra 算法就一定能得到最优解!  

[^1]: 一般的BFS算法可看作将图拉成树, 遍历时不会考虑兄弟节点之间的访问, 故而有些时候最优解出现在兄弟节点之间的访问时, 算法无法得到最优解  
[^2]: PQ中的元素可以是一个 (顶点:路径长度)类, 优先队列按照路径长度进行判断, 顶点入队时, 计算路径长度并存入, 如果已经存在, 进行更新 (书上称之为relax)   
[^3]: 已经出队的顶点的路径值不会更新, 如果存在负边指向已出队的顶点, 并且此路径最优, 算法会出现问题  

### A* 算法

遍历整个图的顶点还是有点傻, A* 算法基于一种启发式函数 h(v, goal) ,路径长度需要加上h的值再存入PQ中, 启发式函数的值可能是无穷大, 这给我们提供了一种剪枝的机会. 具体启发式函数的构造很复杂, 这里只是介绍这种算法.
