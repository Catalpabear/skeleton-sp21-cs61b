[Goto Overview](./总览.md)

### 处理二维点集

现在我们假设平面坐标系上有一组数量庞大的点, 并给定一个点S, 我们需要找到点集里离S最近的点.      
数量过大, 我们只能使用哈希表储存数据, 问题便出现了 : 使用一般的 `hashcode` 函数,生成的哈希码往往是随机的, 我们要得到与S点最近的点, 必须遍历整个哈希表 , 得到O(N)的时间复杂度.     

我们必须改进 `hashcode`函数, 使其通过 对象的 `getX()` `getY()` 方法进行计算, 这样哈希表的
' 桶 '(bucket) 就与点的坐标相关, 我们解决问题, 可以先遍历S点可能分到的桶,再遍历附近的桶  

![](./picturefield/hash-partition.png)
<small>书上对此进行了16 划分</small>  

平均而言，使用空间划分后，运行速度将比不使用空间划分时快 16 倍，但不幸的是 N/16​​​ 仍然是 O(N)。但是，这确实在实践中效果更好。

### 四叉树引入

每个点都有两个属性, X坐标和Y坐标, 这些显然是可比较的, 我们可以针对这一点构建BST 
一开始可以只针对X或Y坐标进行构建BST, 但是难免有一些不好之处, 一般情况下查找操作可以达到O(logN), 当在某些情况下, 我们不得不遍历整个树

我们需要针对XY两个坐标值构建, 一共出现四种情况, 这就是四叉树
### 用四叉树解决问题

我们可以以某个父节点为原点构建坐标系, 按四个象限分配其子节点
NW NE SE SW
```java
public class QuadtreeNode<X,Y>{
	X xpos;
	Y ypos;
	QuadtreeNode NW;
	QuadtreeNode NE;
	QuadtreeNode SE;
	QuadtreeNode SW;
}
```
如果你试图画出四叉树在二维空间上的图, 你会发现父子节点之间的关系并不明确, 画画树图就好

我们将节点插入四叉树中, 然后试着针对S点遍历整个树(遍历的时候测算距离), 加上一些剪枝

 **确定搜索顺序**：根据目标点位置，决定4个子区域的访问顺序
    - 优先搜索目标点所在的子区域（最可能有最近点）    
    - 然后按距离由近到远搜索其他子区域
 **递归搜索子区域**：
    - 对每个子区域，先计算它到目标点的最小可能距离    
    - 只有这个最小距离 < 当前最短距离时，才需要搜索这个子区域 -> **剪枝**   
    -（否则这个区域不可能有更近的点，直接跳过）

搜索的效率看似复杂, 效率很高
### 更高维

我们将这个思路扩展到三维, 四维情况, 那就需要  $2^n$  个子节点, 太可怕了.  
书上介绍了一种 K-D Tree , 可以处理任意维度的数据, 它的工作原理是逐层通过所有维度进行旋转。
看看一个简单的定义:
```java
public class KDNode {
    double[] elem;
    int axis;
    KDNode left, right;
    
    KDNode(double[] elem, int axis) {
        this.elem = elem.clone();
        this.axis = axis;
    }
}
```
elem是一个维度数组, 你有几维的数据, 数组的长度就多大
axis表示以第几维度的数据作为BST比较的对象
例如, 初始存在 (1, 3, 2)为根节点, 其`axis`为0 , 插入(3, 4, 9), 我们会比较3和1, 然后将349插到根节点的右边, 其`axis` 置为1.  
- 如果出现比较结果相等的情况, 视为大于
- `axis` 的值和树的层数有关, 假如是n维, `axis = height % n`  height是节点离根的距离 
 注: 如果带入二维的思路去看, 很容易理解`axis` 为什么是轴