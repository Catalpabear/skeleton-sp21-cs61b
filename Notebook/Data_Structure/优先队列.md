[Goto Overview](./总览.md)

---
### 需求分析

BST的搜索性能达成了对数级,但如果我们更关心快速找到最小或最大的元素，而不是快速搜索会怎样呢？
这里我们使用优先队列:
```java
/* (Min) Priority Queue: Allowing tracking and removal of 
  * the smallest item in a priority queue. 
  * 优先队列：允许跟踪和删除优先队列中的最小项目*/
public interface MinPQ<Item> {
    /** Adds the item to the priority queue. */
    public void add(Item x);
    /** Returns the smallest item in the priority queue. */
    public Item getSmallest();
    /** Removes the smallest item from the priority queue. */
    public Item removeSmallest();
    /** Returns the size of the priority queue. */
    public int size();
}
```
我们用什么数据结构构建它
- 有序数组  -> 插入操作最差$\large O(N)$
- BST           -> 操作均为O(logN)
- 哈希表      -> 查找最小数耗时更长
目前看来BST最优, 但是实现难度大

### Heap 

我们对二叉树进行了改造, 现在它叫 Heap
- 每个节点都小于或等于其两个子节点
- 只能底层缺失,且如果底层缺失，所有节点尽可能靠左  

现在看看用它构建优先队列(PQ)的方法怎么样: 
- add -> $O(logN)$
- getSmallest -> $O(1)$
- removeSmallest ->$O(logN)$ 
#### add
在树的最后插入, 将其与父节点比较, 如果小于则替换
#### getSmallest
返回根节点
#### removeSmallest
移除根节点, 将最后一个节点放在根处, 再向下比较交换(向左右方向均可)

#### 实现Heap

Heap 的本质是二叉树，并非BST，我们需要先探讨树的实现方法

- 链表结构
	- 储存子节点的指针 -> 一般实现方法
	- 使用子节点指针数组 -> 子节点过多时使用
	- 将树的每一层视为一个链表, 链表首地址相连
- 双数组结构 -> 一个value数组 + 一个parents数组(储存当前索引表示节点的父节点)
- 单数组结构 -> 当树的结构很整齐,有规律, parents的索引值可以通过简单的算法给出

我们使用单数组结构, 堆的只能底层缺失的性质决定它的结构整齐
这需要parent方法 , leftchild rightchild方法, swim方法
可以把数组的0索引位置空出, 可以让上述方法实现更美观

